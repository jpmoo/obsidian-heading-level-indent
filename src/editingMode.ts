/* eslint-disable no-constant-condition */
/* eslint-disable @typescript-eslint/no-unused-vars */
import { syntaxTree } from "@codemirror/language";
import {
	// concerned about what the document looks like (while also managing the state of the rest of the editor)
	// the state focuses exclusively on re-computing changes to the state based off of inputs and nothing else
	EditorState,
	Extension,
	RangeSetBuilder,
	StateEffect,
	StateField,
	Transaction
} from "@codemirror/state";
import {
	Decoration,
	DecorationSet,
	// concerned about what the DOM looks like
	// may produce a side effect as a result of the change in state
	EditorView,
	ViewPlugin,
	ViewUpdate
} from "@codemirror/view";

/**
 * indentStateField stored value.
 */
interface DecorationSetWithIntervals {
	/**
	 * Indent decorations for text lines.
	 */
	decorations: DecorationSet;

	/**
	 * Array containing text ranges inside markdown and their corresponding indents. It is generated by indentStateField
	 * while it processes markdown content and is used by indentEmbedsPlugin to indent the DOM elements (embeds, images
	 * etc.). Example array: [[11, 30], [356, 50], [1381, 30]] means:
	 * - apply indent 0 to all DOM html elements corresponding to positions between 0 and 11 in source markdown document
	 * - apply indent 30 to all DOM html elements corresponding to positions between 11 and 356 in source markdown
	 *   document
	 * - apply indent 50 betwwen 356 and 1381
	 * - apply indent 30 between 1381 and the end of the document
	 */
	intervals: [number, number][];
}

export const indentStateField = StateField.define<DecorationSetWithIntervals>({
	create(state): DecorationSetWithIntervals {
		return getDecorationSet(state);
	},

	/**
	 * lifecicle for an update: DOM event -> transaction -> create new state -> view update
	 */
	update(currentValue: DecorationSetWithIntervals, tr: Transaction): DecorationSetWithIntervals {
		// in case of container resize or settings update
		for (const e of tr.effects) {
			if (e.is(updateNeededNotificationEffect)) {
				return getDecorationSet(tr.state);
			}
		}

		// in case of markdown content change
		if (syntaxTreeChanged(tr)) {
			return getDecorationSet(tr.state);
		}

		return currentValue;
	},

	provide(field: StateField<DecorationSetWithIntervals>): Extension {
		return EditorView.decorations.from(field, (value) => value.decorations);
	}
});

function syntaxTreeChanged(tr: Transaction): boolean {
	const oldTree = syntaxTree(tr.startState);
	const newTree = syntaxTree(tr.state);
	return oldTree !== newTree;
}

function getDecorationSet(state: EditorState): DecorationSetWithIntervals {
	/**
	 * scan headings across document
	 */
	const settings = (window as any).app.plugins.plugins["heading-level-indent"].settings;

	const headings: {
		text: string;
		level: number;
		headingLineNumber: number;
		headingPos: number;
	}[] = [];

	let highestLevelInDocument = 6;

	syntaxTree(state).iterate({
		enter(node) {
			if (node.type.name.startsWith("HyperMD-header_HyperMD-header-")) {
				const lineAt = state.doc.lineAt(node.from);
				const text = state.doc.sliceString(node.from, node.to);
				const level = Number(node.type.name.slice(-1));
				const posAt = node.from;

				headings.push({
					text: text,
					level: level,
					headingLineNumber: lineAt.number,
					headingPos: posAt
				});

				highestLevelInDocument = Math.min(highestLevelInDocument, level);
			}
		}
	});

	if (settings.treatHighestPresentHeadingAsH1) {
		for (const heading of headings) {
			heading.level -= highestLevelInDocument - 1;
		}
	}

	const builder = new RangeSetBuilder<Decoration>();

	const el = document.querySelector(".workspace-leaf.mod-active .cm-content");
	if (el === null) return { decorations: Decoration.none, intervals: [] };

	const containerWidth = parseInt(getComputedStyle(el).width);

	const intervals: [number, number][] = [];

	for (const [index, heading] of headings.entries()) {
		const { level, headingLineNumber, headingPos } = heading;
		const headingLine = state.doc.line(headingLineNumber);

		const firstDataLineNumber = headingLineNumber + 1;
		const lastDataLineNumber = headings[index + 1]?.headingLineNumber - 1 || state.doc.lines;

		const pxForDataLine = settings[`h${level}`] || 0;
		const pxForHeadingLine = settings[`h${level - 1}` || 0];

		intervals.push([headingPos, pxForDataLine]);
		const dataStyles =
			`left:${pxForDataLine}px;` +
			// we indent on the left side, so we need to reduce the width of the line also
			`width:${containerWidth - pxForDataLine}px;`;

		const headingStyles =
			`left:${pxForHeadingLine}px;` + `width:${containerWidth - pxForHeadingLine}px;`;

		builder.add(
			headingLine.from,
			headingLine.from,
			Decoration.line({
				attributes: { style: headingStyles }
			})
		);

		for (let j = firstDataLineNumber; j < lastDataLineNumber + 1; j++) {
			const dataLine = state.doc.line(j);
			builder.add(
				dataLine.from,
				dataLine.from,
				Decoration.line({
					attributes: { style: dataStyles }
				})
			);
		}
	}

	return { decorations: builder.finish(), intervals };
}

/**
 * Didn't find a way to indent embeds (images, callouts, tables etc.) in a StateField.
 * Likely their corresponding Widgets are created by Obsidian's private StateFields and it is not possible to
 * effectively access them.
 * After the state has been translated to DOM it is possible to indent the resulting HTML elements.
 * indentStateField calculates intervals array which maps all ranges inside the markdown document to the target indents.
 * In the below ViewPlugin each element of DOM of embed type is mapped to a position in the markdown document and then
 * to its target indent.
 */
export const indentEmbedsPlugin = ViewPlugin.fromClass(
	class {
		constructor(readonly view: EditorView) {
			this.scheduleIndentEmbedsAfterRender();
		}

		update(update: ViewUpdate) {
			// in case of container resize or settings update
			for (const tr of update.transactions) {
				for (const e of tr.effects) {
					if (e.is(updateNeededNotificationEffect)) {
						this.scheduleIndentEmbedsAfterRender();
					}
				}
			}

			// in cases of state change or viewport change (scroll etc.)
			if (update.docChanged || update.viewportChanged) {
				this.scheduleIndentEmbedsAfterRender();
			}
		}

		scheduleIndentEmbedsAfterRender() {
			this.view.requestMeasure({
				read: () => {},
				write: (measure: any, view: EditorView) => {
					const { intervals } = view.state.field(indentStateField);
					const dom = this.view.dom;
					const el = document.querySelector(".workspace-leaf.mod-active .cm-content");
					if (el === null) return;
					const containerWidth = parseInt(getComputedStyle(el).width);

					// Callouts, tables, math blocks.
					// In DOM they are translated to <div> tags.
					const embeds = Array.from(
						dom.querySelectorAll("div.cm-content > div.cm-embed-block")
					) as HTMLDivElement[];
					const mathBlocks = Array.from(
						dom.querySelectorAll("div.cm-content > div.math-block")
					) as HTMLDivElement[];
					// prevIntervalIndex is used to narrow down the scope of the binary search inside findIntervalOffset given
					// that querySelectorAll returns elements in the order of their apeearance in the document.
					let prevIntervalIndex = 0;
					for (const embed of [...embeds, ...mathBlocks]) {
						const [intervalIndex, offset] = findIntervalOffset(
							intervals,
							view.posAtDOM(embed),
							prevIntervalIndex
						);
						prevIntervalIndex = intervalIndex;
						embed.style.left = `${offset}px`;
						embed.style.width = `${containerWidth - offset}px`;
					}

					// Local images and embedded files.
					// In DOM they are translated to <div> tags with another <div> or <img> inside.
					const internalEmbeds = Array.from(
						dom.querySelectorAll("div.cm-content > div.internal-embed")
					) as HTMLDivElement[];
					prevIntervalIndex = 0;
					for (const embed of internalEmbeds) {
						const [intervalIndex, offset] = findIntervalOffset(
							intervals,
							view.posAtDOM(embed),
							prevIntervalIndex
						);
						prevIntervalIndex = intervalIndex;
						embed.style.position = "relative";
						embed.style.left = `${offset}px`;
						embed.style.width = `${containerWidth - offset}px`;
					}

					// Images linked from internet ![image](https://google.com/someimage.jpg).
					// In DOM they are translated to <img> tags without <div> around.
					const imgs = Array.from(
						dom.querySelectorAll("div.cm-content > img")
					) as HTMLImageElement[];
					prevIntervalIndex = 0;
					for (const img of imgs) {
						const [intervalIndex, offset] = findIntervalOffset(
							intervals,
							view.posAtDOM(img),
							prevIntervalIndex
						);
						prevIntervalIndex = intervalIndex;
						img.style.position = "relative";
						img.style.left = `${offset}px`;
						img.style.maxWidth = `${containerWidth - offset}px`;
					}
				}
			});
		}
	}
);

/**
 * Looks for an interval to which pos belongs.
 * Binary search in a sorted array.
 * @returns Tuple containing index of the found interval in the intervals array and its offset.
 */
function findIntervalOffset(
	intervals: [number, number][],
	pos: number,
	start: number
): [number, number] {
	if (!intervals.length || pos < intervals[0][0]) {
		return [0, 0];
	}

	let low: number = start;
	let high: number = intervals.length - 1;
	let result: [number, number] = [0, 0];

	while (low <= high) {
		const mid = (low + high) >> 1;
		const [midPos, midOffset] = intervals[mid];

		if (midPos < pos) {
			result = [mid, midOffset]; // possible candidate
			low = mid + 1; // but maybe there’s a later one
		} else {
			high = mid - 1; // too far, go left
		}
	}

	return result;
}

/**
 * Notification effect which is sent to indentStateField and to indentEmbedsPlugin so that they do the updates.
 * It is sent by:
 *  (1) resizeNotificationPlugin when size of the editor changes,
 *  (2) saveSettings() when settings are changed.
 * It is needed because Obsidian and CM do not provide ways (flag etc.) to check that editor size or settings have changed.
 * Regarding editor size: there is only ViewUpdate.geometryChanged available in the ViewPlugin (and not in StateField by design).
 */
export const updateNeededNotificationEffect = StateEffect.define<void>();

/**
 * ViewPlugin that watches for DOM size changes and dispatches update notifications.
 */
export const resizeNotificationPlugin = ViewPlugin.define((view) => {
	let resizeTimeout: number | undefined;

	const observer = new ResizeObserver((entries) => {
		clearTimeout(resizeTimeout);

		// When user changes size by dragging window border, the browser can fire dozens of ResizeObserver callbacks per
		// second. Using a small debounce (100 ms) so transaction is only dispatched when resizing “settles” a bit.
		resizeTimeout = window.setTimeout(() => {
			view.dispatch({
				effects: updateNeededNotificationEffect.of()
			});
		}, 100);
	});

	// Observe the editor's root DOM node
	observer.observe(view.dom);

	return {
		destroy() {
			observer.disconnect();
		}
	};
});
